/*
	1장. 프로그래밍 언어의 소개

	프로그래밍 언어 : 컴퓨터로 수행하고자 하는 바를 컴퓨터에게 전달하기 위한 표현법
					 (프로그래밍 의도를 추상화 -> 컴퓨터에 전달)을 위한 도구
				     언어 구문과 언어 의미로 구성

	
	-구문(Syntax)-

	1. 촘스키 계층 : 프로그래밍 언어들의 관계를 나타내는 계층                           
	   
	   정규 문법 <= 문맥 자유 문법 <= 문맥 의존 문법 <= 무제한 문법

	2. 문맥 자유 문법 종류

		BNF 표기법 : 프로그래밍 언어의 구문을 서술가능한 표기법
		
		EBNF 표기법 : BNF의 확장 표기법. 메타 기호 등을 추가.


	-의미론(semantics)-

	 작성된 수식,문장,프로그램의 의미를 정함. 

	 1. 작동 의미론 : 프로그램의 의미를 실행(작동)과정을 기술하여 정의하는 정형화된 방법

	 2. 표기 의미론 : 프로그램 내의 수식,문장을 표기라는 수학적 함수의 형태로 정의하는 방법
	
	 3. 공리 의미론 : 수학적 논리 기반, 프로그램 요소의 사전 조건,후행 조건을 통해 프로그램 의미 정의 -> 정확성 증명하는데 사용

*/
/*
	1장. 언어번역(Compile)

		컴파일 : 고급 언어로 작성된 프로그램 => (변환) => 컴퓨터가 바로 실행할 수 있는 프로그램
		컴파일러 : 컴파일을 하는 프로그램
		원시 프로그램(Source Program) : 고급 언어로 작성된 프로그램
		목적 프로그램(Object Program) : 컴파일로 생성된 기계어 프로그램

		컴파일러의 처리 과정 : 	
	
		원시 프로그램 => 컴파일(번역) => 목적 프로그램 => 링커/로더(실행) => 결과
							|
							|
							|
							V
						컴파일 단계

		원시 프로그램 => 어휘 분석 =>	구문 분석 =>	 중간 코드 생성 => 최적화 => 코드 생성 => 목적 프로그램



		0. 어휘 분석 단계

		원시 프로그램을 토큰이라는 단위로 나누고, 이들을 다음 단계로 전달한다.

		1 .구문 분석 단계

		전달받은 토큰들을 문법 검사, 오류가 없다면 파스 트리 구조 생성

		2. 중간코드 생성 단계

		기계어에 가까운 중간 코드로 이루어진 프로그램 생성. 문법적 오류가 아닌 의미적 오류를 검사.

		3. 최적화 단계

		중간 코드를 효율적인 코드로 개선해 속도를 빠르게 다듬는 과정.

		4. 코드 생성 단계 

		최적화된 중간 코드로부터 컴퓨터가 실행가능한 목적 프로그램 생성.

*/
/*
	3장. 프로그래밍 언어 약사

	-1950년대 : 고급 프로그래밍 언어의 시작-

		0. FORTRAN
			
		최초의 고급 언어. 과학 계산용 설계.

		매우 빠른 컴파일

		1. COBOL(Common Business-Oriented Languagle)

		사무용 설계. 절차적, 명령형 언어

		영어와 비슷한 구문. -> 쉬운 난이도,
		데이터를 조직하는 레코드 구조, 자료구조가 프로그램 실행부분과 분리,다양한 출력 기능 
		영어와 비슷한 구문 탓에 복잡한 알고리즘 설계 어려움

		2. LISP(LIst Processor)

		폰 노이만 구조 기반 언어(FORTRAN,COBOL)과는 달리 수학 함수의 개념 기반.

		인공지능용 설계. List 자료구조 및 함수 적용 기반
		재귀 호출이 일반적으로 사용됨.
		런타임 때 기억장소 관리 및 사용되지 않는 기억장소 자동 반환 기능(가비지 컬렉터) 기능 도입

		후속언어로는 Scheme 
		함수형 프로그래밍의 선구자.

	-1960년대 : 프로그래밍 언어의 다양성- // --------------------------------------------------------------------------------> 여기까지 공부.

		0. Algol 60/68
		
		알고리즘을 기술하기 위한 설계,현재 알고리즘 기술 위해 Algol형태 구문 사용됨.
		구조적 문장,begin~end 블록,자유 양식,변수의 타입 선언,재귀 호출, 값 전달 매개변수 등 새로운 개념 도입
		블록 구조. 스택 기반 실행환경 도입.
		구문을 정의하기 위해 BNF 표기법 최초 사용.

		-> PasCal,C,Modula-2,Ada 등 명령형 언어에 영향을 미침

		1. PL/I

		모든 언어를 통합하는 언어를 바탕으로 설계
		FORTRAN,COBOL,Algol60의 특징에 병행성,예외처리 기능 추가된 언어.
		
		심각한 복잡성 -> 컴파일러 작성 어려움
		컴파일러의 크기가 크고,속도가 느려,신뢰할 수 없음
		기능들 사이 예측할 수 없는 상호작용이 많음
		높은 난이도.

		의의: 좋은 기능을 포괄하는 언어가 꼭 좋은 언어는 아님.

		2.Simula-67

		최초의 객체 지향 언어(원조). 모의실험을 위한 설계
		객체와 클래스 개념 소개 ->추상화에 근본적 공헌

		3.BASIC
		
		단순한 설계 -> 교육용 언어,PC 응용을 위한 언어로 사용됨
		시각적 개발환경 및 접근 난이도 낮음 -> 초보자가 배우기 쉬움.
		초기 버전에 현대적 언어 구조의 결여 존재.
		Visual Basic 형태로 발전

	-1970년대 : 단순성 및 새로운 언어의 추구-

		0.Pascal

		교육용 설계. Algol의 장점을 살려, 효율적,구조화된 설계.
		단점 : 분리 컴파일,문자 스트링 처리,확장 인출력 기능 부재.
		
		-> 교육용,실제 응용에서 널리 쓰임.

		1. C언어

		유닉스 OS 개발용.
		실질적으로 모든 컴퓨터에서 사용가능하도록 설계됨
		OS 개발 언어 -> 하드웨어에 대한 많은 접근 사용 가능.

		2. Prolog

		프로그래밍 언어에서 직접 수학적 논리를 사용하기 위한 설계.
		논리식을 토대로 개체 간 관계 문제 해결하도록 사용됨.
		P->Q 형태의 술어 논리 구조.
		
		사실,논리 규칙 형태의 프로그램의 실행 -> 사실의 증명

		추론 기구를 간결하게 표현가능 -> AI,계산언어학,자연어처리에 사용됨

		3.Scheme,ML

		Scheme : 람다 계산에 가깝게 설계된 LISP

		ML : Pascal과 가까운 구 및 유사한 타입 검사 매커니즘의 함수형 언어
		

	-1980년대 : 추상 자료형과 객체지향-

		Ada: 

/*
	4장. 프로그래밍 언어의 설계 원칙





*/